/**
 * Configurations declarations
 */

import "state_messages.proto";

package anantak;

// DataQueue configuration
message DataQueueConfig {
  optional string name = 1;               // name of this configuration
  optional float cycle_frequency = 2;     // cycling frequency of the main loop
  optional string publisher_name = 10;    // name of the publisher
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  optional bool load_data_at_start = 22;  // if true, loads sensor data from files at start
  
  message Sensor {
    required string name = 1;
    optional int32 queue_length = 2;
    optional bool track = 3;
    optional int32 track_length = 4;
    optional string data_file = 5;
  }
  message DataSubscriber {
    required string name = 1;
  }
  repeated Sensor sensor = 30;                      // Sensors to get data from
  repeated DataSubscriber data_subscriber = 40;     // DataSubscribers to send data to
}

// MessageFilesPublisher configuration
message MessageFilesPublisherConfig {
  optional string name = 1;               // Name of this configuration
  optional float cycle_frequency = 2;     // Cycling frequency of the files publisher
  optional int64 data_start_time = 3;     // Start time of the recorded data of all sensors
  optional string publisher_name = 10;    // name of the publisher
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  
  message Sensor {
    required string name = 1;             // Name of sensor - should match name in ProgramsSetup
    required string data_file = 2;        // File with the data to be loaded for this sensor
  }
  repeated Sensor sensor = 30;
}

/** Sliding Window Filter configuration
 *    Max sliding window size, iteration interval and observation frequency are used to estimate
 *    the memory size allocation kept. When sizes 
 **/
message FilterConfig {  
  // Filter specs
  optional string name = 1;
  optional float cycle_frequency = 2;     // Cycling frequency of the files publisher
  optional int64 max_sliding_window_interval = 3;   // Maximum sliding window interval musec
  optional int64 max_iteration_interval = 4;        // Maximum iteration interval musec
  optional float max_observation_frequency = 5;     // Maximum frequency of observations (Hz)
  
  // Component specs
  optional string publisher_name = 10;    // name of the main publisher 
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  
  message DataQueue {                   // Sources of observations and calibrations
    required string name = 1;           // Name of the data queue - should match name in Settings
  }
  repeated DataQueue data_queue = 30;     // Filter can have multiple data queues
  
  // Data queues to be polled for observations in every iteration
  repeated string observations_data_queue_names = 31;
  
  message ObservationType {             // Observation types that the filter expects to see
    required string name = 1;             // HeaderMsg.Type strings in sensor msgs
    optional float max_frequency = 2;     // Maximum expected frequency of observations (Hz)
    optional int32 max_msgs_per_iteration = 3; // = max_frequency * max_iteration_interval
  }
  repeated ObservationType observation_type = 40; // Filter acts on many types of observations
  
  /** Models prepare the states and residuals from observations; then solve the problem */
  message Model {
    required string name = 1;           // Name of the model. Used to match with commands
    required string type = 2;
    required string config_file = 3;    // Config file for the model, passed to the model at start
    optional string short_name = 4;     // Short name given to the model
    
    /* Model's results message will be transmitted on the subject. This usually is the name
     * of the component receiving the messages */
    required string results_subject = 10;   // subject at which the results will be published
    required int32 results_frequency = 11;  // frequency at which results will be published
    
    /* At the start of model, filter will ask for latest message from a queue. Usually this is used
     * for calibration data. Data will come into observations of the filter. Below we specify
     * the queue name and the sensor that will be polled for the starting data. If these are not
     * declared, starting calibrations will not be polled. */
    optional string results_queue = 12;
    optional string results_sensor = 13;
  }
  repeated Model model = 50;              // There are many models in a filter
  
}

message ImagesBroadcasterConfig {
  optional string name = 1;               // name of this configuration
  optional float cycle_frequency = 2;     // cycling frequency of the main loop
  optional string publisher_name = 10;    // name of the publisher
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  
  optional int32 num_cameras = 30;              // number of cameras to connect to
  optional int32 frame_rate = 31;               // frame rate to use usually 30Hz or 60 Hz
  optional int32 image_width = 32;              // image width e.g. 640 for VGA resolution
  optional int32 image_height = 33;             // image height e.g. 480 for VGA resolution
  optional int32 image_depth = 34;              // 3 for color and 1 for monochrome
  optional int32 image_size = 35;               // number of bytes in image = width*height*depth = 921600 for VGA colored
  
  message PointGreyCamera {
    required string name = 1;
    required int64 id = 2;
  }
  repeated PointGreyCamera pg_camera = 40;      // Cameras to get data from
}

message ImagesProcessorConfig {
  optional string name = 1;               // name of this configuration
  optional float cycle_frequency = 2;     // cycling frequency of the main loop
  optional string publisher_name = 10;    // name of the publisher
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  optional string images_broadcaster_name = 22;       // name of the images broadcaster subscription
  
  optional int32 num_cameras = 30;              // number of cameras to connect to
  optional int32 image_width = 32;              // image width e.g. 640 for VGA resolution
  optional int32 image_height = 33;             // image height e.g. 480 for VGA resolution
  optional int32 image_depth = 34;              // 3 for color and 1 for monochrome
  optional int32 image_size = 35;               // number of bytes in image = width*height*depth = 921600 for VGA colored
  
  message CameraToProcess {
    required string name = 1;
    required int32 num = 2;
  }
  repeated CameraToProcess camera = 40;      // Cameras to get data from
  
  message BeaconDetector {
    required string tag_publisher_name = 1;
    required string tag_publisher_subject = 2;
    optional int32 num_tags = 3;
    optional string blob_publisher_name = 4;
    optional string blob_publisher_subject = 5;
    optional int32 num_blobs = 6;
  }
  optional BeaconDetector beacon_detector = 45;
}

message PixyCameraConfig {
  optional string name = 1;               // name of this configuration
  optional float cycle_frequency = 2;     // cycling frequency of the main loop
  optional string publisher_name = 10;    // name of the publisher
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  
  optional string symlink = 30;                 // symlink of the pixy camera
  optional int32 image_width = 32;              // image width e.g. 320 for pixy
  optional int32 image_height = 33;             // image height e.g. 200 for pixy
  optional int32 image_depth = 34;              // 3 for color and 1 for monochrome
  optional int32 image_size = 35;               // number of bytes in image = width*height*depth = 921600 for VGA colored  
}

message SerialMonitorConfig {
  optional string name = 1;               // name of this configuration
  optional float cycle_frequency = 2;     // cycling frequency of the main loop
  optional string publisher_name = 10;    // name of the publisher
  optional string commander_name = 20;    // name of the commander subscription
  optional string status_name = 21;       // name of the status query subscription
  
  optional string symlink = 30;           // symlink of the serial connection
}

/** Sliding Window Options configuration */
message SlidingWindowOptionsConfig {
  required uint64 longest_problem_interval = 1;     // longest problem length
  required uint64 shortest_problem_interval = 2;    // shortest problem length
  required uint64 sliding_window_interval = 3;      // sliding window length
  required uint64 solving_problem_interval = 4;     // solving problem interval
}

/** Beacon configuration */
message BeaconConfig {
  repeated StaticApriltagStateMessage tags = 1;
  repeated LedMessage leds = 2;
  repeated ImuMessage imus = 3;
}

/** Camera intrinsics initialization configuration
 * Usually used as starting for the intrinsics calibration of a camera */
message CameraIntrinsicsInitMessage {
  required double angle_of_view = 1;      // in radians
  repeated double image_size = 2;
  // Distortions?
  required double angle_of_view_stdev = 21;   // in radians
  required double center_stdev = 22;
}

/** April tag view residual options config
 * Used by Static and DynamicAprilTagViewResidual to build options */
message AprilTagViewResidualOptionsConfig {
  required double sigma_image = 1;      // stdev of the sighting on the image
}

/** Beacon camera calibrator config
 * Configuration for the filter that run beacon-based camera calibrator */
message BeaconCameraCalibratorConfig {
  
  // States specifications
  required string name = 1;   // name of the configuration
  required uint64 states_history_interval = 2; // How long a history of states to keep (musec)
  required uint64 states_frequency = 3;        // Frequency of creation of states liked to wall time
  
  // Sliding window specifications
  required SlidingWindowOptionsConfig sliding_window = 10;    // Sliding window specs
  
  // Camera specifications
  required uint32 camera_num = 20;   // Camera number of the camera being calibrated - for messages
  required uint32 max_camera_frequency = 21;  // Maximum frequency of camera images
  required CameraIntrinsicsInitMessage camera_init = 22;  // Starting intrinsics
  
  // Beacon specifications
  required BeaconConfig beacon = 30;  // Beacon specs with tags, leds and imus
  
  // Residuals specifications
  required AprilTagViewResidualOptionsConfig apriltag_view_resid_options = 40; 
}

